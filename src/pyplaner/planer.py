import io
import os
import pathlib
import time
from contextlib import contextmanager
from typing import Callable, Iterator
from urllib.parse import urlparse, unquote

import jinja2
import markupsafe
from playwright.sync_api import Route, sync_playwright

from .calendar import Calendar

try:
    import pikepdf
    from .optimize_pdf import optimize_pdf
except ImportError:
    pikepdf = None  # type: ignore[assignment]


@contextmanager
def _timed(phase: str,
           cb: Callable[[str, float], None] | None) -> Iterator[None]:
    t0 = time.perf_counter()
    yield
    if cb:
        cb(phase, time.perf_counter() - t0)


def _asset_route(r: Route) -> None:
    """Route requests generated by the browser to the local file system.

    :param r: Playwright :class:`~playwright.sync_api.Route` to fulfill.
    """
    parse_result = urlparse(r.request.url)
    path = unquote(parse_result.path)

    if parse_result.netloc:
        # file://hostname/path -> ignore hostname for local files
        path = f"{parse_result.netloc}{path}"
    elif path.startswith("/") and ":" in path[1:3]:
        # Windows: strip leading slash in /C:/path
        path = path[1:]

    r.fulfill(path=path)


class Planer:
    """Render a Jinja2/HTML planner template into HTML or PDF.

    :param template_path: Path to the Jinja2/HTML template file.
    :param calendar: :class:`~pyplaner.calendar.Calendar` instance used for
        template rendering.
    """

    def __init__(self, template_path: str | os.PathLike,
                 calendar: Calendar | None = None,
    ) -> None:
        if calendar is None:
            calendar = Calendar()
        self._path = pathlib.Path(template_path).absolute()

        self._env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(self._path.parent),
            autoescape=jinja2.select_autoescape(),
            trim_blocks=True,
            lstrip_blocks=True,
            line_statement_prefix="%%",
            line_comment_prefix="##"
        )
        self._template = self._env.get_template(self._path.name)
        self.calendar = calendar

    def html(self) -> str:
        """Render the template and return the resulting HTML string.

        :returns: Rendered HTML.
        """
        return self._template.render(
            planner_head="",
            calendar=self.calendar,
            lang=self.calendar.lang,
        )

    def pdf(self,
            margin_top: str | float | None = None,
            margin_right: str | float | None = None,
            margin_bottom: str | float | None = None,
            margin_left: str | float | None = None,
            pdf_optimize: bool = True,
            timing_cb: Callable[[str, float], None] | None = None,
            ) -> bytes:
        """Render the template and return a PDF as raw bytes.

        :param margin_top: Top page margin (CSS length or ``None``).
        :param margin_right: Right page margin (CSS length or ``None``).
        :param margin_bottom: Bottom page margin (CSS length or ``None``).
        :param margin_left: Left page margin (CSS length or ``None``).
        :param pdf_optimize: If ``True`` (default) and ``pikepdf`` is
            available, post-process the PDF to deduplicate images and
            strip obsolete metadata.
        :param timing_cb: Optional callback invoked with ``(phase, seconds)``
            after each processing stage.
        :returns: PDF file content as bytes.
        """
        with _timed("html_render", timing_cb):
            planner_head = markupsafe.Markup('<base href="file://.">')
            html = self._template.render(
                planner_head=planner_head,
                calendar=self.calendar,
                lang=self.calendar.lang,
            )

        with sync_playwright() as p:
            with _timed("browser_launch", timing_cb):
                browser = p.chromium.launch(args=[
                    "--allow-file-access-from-files",
                    "--disable-web-security",
                ])

            page = browser.new_page()
            page.on("requestfailed",
                lambda r: print(f'Failed to load "{r.url}"'))
            page.route("file://**/*", _asset_route)

            with _timed("set_content", timing_cb):
                page.set_content(html, wait_until="load")
                page.evaluate("() => document.fonts.ready")

            with _timed("page_pdf", timing_cb):
                pdf = page.pdf(
                    print_background=True,
                    prefer_css_page_size=True,
                    margin={
                        "top": margin_top,
                        "right": margin_right,
                        "bottom": margin_bottom,
                        "left": margin_left,
                    },
                )

            browser.close()

        if pikepdf is None:
            return pdf

        with _timed("pikepdf", timing_cb):
            with pikepdf.open(io.BytesIO(pdf)) as pike_pdf_obj:
                if pdf_optimize:
                    optimize_pdf(pike_pdf_obj)
                bio = io.BytesIO()
                pike_pdf_obj.save(bio,
                    object_stream_mode=pikepdf.ObjectStreamMode.generate,
                    recompress_flate=True,
                )
                return bio.getvalue()
