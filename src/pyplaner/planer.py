import os
import pathlib
import time
import jinja2
from typing import Callable
from urllib.parse import urlparse, unquote
from playwright.sync_api import Route, sync_playwright
from .calendar import Calendar

try:
    import pikepdf
    import io
except ImportError:
    pikepdf = None # type: ignore[assignment]

def _asset_route(r: Route) -> None:
    """Route requests generated by the browser to the local file system"""
    parse_result = urlparse(r.request.url)
    path = unquote(parse_result.path)

    if parse_result.netloc:
        # file://hostname/path -> ignore hostname for local files
        path = f"{parse_result.netloc}{path}"
    elif path.startswith("/") and ":" in path[1:3]:
        # Windows: strip leading slash in /C:/path
        path = path[1:]

    r.fulfill(path=path)


class Planer:
    def __init__(self, template_path: str | os.PathLike,
                 base: str, calendar: "Calendar" = Calendar()
    ) -> None:
        self._path = pathlib.Path(template_path).absolute()
        self.base  = base

        self._env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(self._path.parent),
            autoescape=jinja2.select_autoescape(),
            trim_blocks=True,
            lstrip_blocks=True,
            line_statement_prefix="%%",
            line_comment_prefix="##"
        )
        self._template = self._env.get_template(self._path.name)
        self.calendar = calendar

    def html(self) -> str:
        """Performs parameter substitution and returns resulting HTML"""
        return self._template.render(
            base=self.base,
            calendar=self.calendar
        )

    def pdf(self, html: str | None = None,
            margin_top: str | float | None = None,
            margin_right: str | float | None = None,
            margin_bottom: str | float | None = None,
            margin_left: str | float | None = None,
            timing_cb: Callable[[str, float], None] | None = None,
            ) -> bytes:
        """Print PDF"""
        if html is None:
            html = self.html()

        with sync_playwright() as p:
            t0 = time.perf_counter()
            browser = p.chromium.launch(args=[
                # allows file access
                "--allow-file-access-from-files",
                "--disable-web-security"
            ])
            if timing_cb:
                timing_cb("browser_launch", time.perf_counter() - t0)

            page = browser.new_page()
            page.on("requestfailed",
                lambda r: print(f'Failed to load "{r.url}"'))
            page.route("file://**/*", _asset_route)

            t0 = time.perf_counter()
            page.set_content(html, wait_until="load")
            if timing_cb:
                timing_cb("set_content", time.perf_counter() - t0)

            t0 = time.perf_counter()
            pdf = page.pdf(
                print_background=True,
                prefer_css_page_size=True,
                margin={
                    "top": margin_top,
                    "right": margin_right,
                    "bottom": margin_bottom,
                    "left": margin_left
                }
            )
            if timing_cb:
                timing_cb("page_pdf", time.perf_counter() - t0)

            browser.close()

        if pikepdf is None:
            return pdf

        t0 = time.perf_counter()
        with pikepdf.open(io.BytesIO(pdf)) as pike_pdf_obj:
            bio = io.BytesIO()
            pike_pdf_obj.remove_unreferenced_resources()
            pike_pdf_obj.save(bio,
                object_stream_mode=pikepdf.ObjectStreamMode.generate,
                recompress_flate=True
            )
            if timing_cb:
                timing_cb("pikepdf", time.perf_counter() - t0)
            return bio.getvalue()
