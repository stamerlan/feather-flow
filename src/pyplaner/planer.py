import os
import pathlib
import time
from typing import Callable
from urllib.parse import urlparse, unquote

import jinja2
import markupsafe
from playwright.sync_api import Route, sync_playwright

from .calendar import Calendar

try:
    import pikepdf
    from .optimize_pdf import optimize_pdf
    import io
except ImportError:
    pikepdf = None  # type: ignore[assignment]


def _asset_route(r: Route) -> None:
    """Route requests generated by the browser to the local file system.

    :param r: Playwright :class:`~playwright.sync_api.Route` to fulfill.
    """
    parse_result = urlparse(r.request.url)
    path = unquote(parse_result.path)

    if parse_result.netloc:
        # file://hostname/path -> ignore hostname for local files
        path = f"{parse_result.netloc}{path}"
    elif path.startswith("/") and ":" in path[1:3]:
        # Windows: strip leading slash in /C:/path
        path = path[1:]

    r.fulfill(path=path)


class Planer:
    """Render a Jinja2/HTML planner template into HTML or PDF.

    :param template_path: Path to the Jinja2/HTML template file.
    :param calendar: :class:`~pyplaner.calendar.Calendar` instance used for
        template rendering.
    """

    def __init__(self, template_path: str | os.PathLike,
                 calendar = Calendar()
    ) -> None:
        self._path = pathlib.Path(template_path).absolute()

        self._env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(self._path.parent),
            autoescape=jinja2.select_autoescape(),
            trim_blocks=True,
            lstrip_blocks=True,
            line_statement_prefix="%%",
            line_comment_prefix="##"
        )
        self._template = self._env.get_template(self._path.name)
        self.calendar = calendar

    def html(self) -> str:
        """Render the template and return the resulting HTML string.

        :returns: Rendered HTML.
        """
        return self._template.render(
            planner_head="",
            calendar=self.calendar,
            lang=self.calendar.lang,
        )

    def pdf(self,
            margin_top: str | float | None = None,
            margin_right: str | float | None = None,
            margin_bottom: str | float | None = None,
            margin_left: str | float | None = None,
            pdf_optimize: bool = True,
            timing_cb: Callable[[str, float], None] | None = None,
            ) -> bytes:
        """Render the template and return a PDF as raw bytes.

        :param margin_top: Top page margin (CSS length or ``None``).
        :param margin_right: Right page margin (CSS length or ``None``).
        :param margin_bottom: Bottom page margin (CSS length or ``None``).
        :param margin_left: Left page margin (CSS length or ``None``).
        :param pdf_optimize: If ``True`` (default) and ``pikepdf`` is
            available, post-process the PDF to deduplicate images and
            strip obsolete metadata.
        :param timing_cb: Optional callback invoked with ``(phase, seconds)``
            after each processing stage.
        :returns: PDF file content as bytes.
        """
        t0 = time.perf_counter()
        planner_head = markupsafe.Markup('<base href="file://.">')
        html = self._template.render(
            planner_head=planner_head,
            calendar=self.calendar,
            lang=self.calendar.lang,
        )
        if timing_cb:
            timing_cb("html_render", time.perf_counter() - t0)

        with sync_playwright() as p:
            t0 = time.perf_counter()
            browser = p.chromium.launch(args=[
                # allows file access
                "--allow-file-access-from-files",
                "--disable-web-security"
            ])
            if timing_cb:
                timing_cb("browser_launch", time.perf_counter() - t0)

            page = browser.new_page()
            page.on("requestfailed",
                lambda r: print(f'Failed to load "{r.url}"'))
            page.route("file://**/*", _asset_route)

            t0 = time.perf_counter()
            page.set_content(html, wait_until="load")
            page.evaluate("() => document.fonts.ready")
            if timing_cb:
                timing_cb("set_content", time.perf_counter() - t0)

            t0 = time.perf_counter()
            pdf = page.pdf(
                print_background=True,
                prefer_css_page_size=True,
                margin={
                    "top": margin_top,
                    "right": margin_right,
                    "bottom": margin_bottom,
                    "left": margin_left
                }
            )
            if timing_cb:
                timing_cb("page_pdf", time.perf_counter() - t0)

            browser.close()

        if pikepdf is None:
            return pdf

        t0 = time.perf_counter()
        with pikepdf.open(io.BytesIO(pdf)) as pike_pdf_obj:
            if pdf_optimize:
                optimize_pdf(pike_pdf_obj)
            bio = io.BytesIO()
            pike_pdf_obj.save(bio,
                object_stream_mode=pikepdf.ObjectStreamMode.generate,
                recompress_flate=True
            )
            if timing_cb:
                timing_cb("pikepdf", time.perf_counter() - t0)
            return bio.getvalue()
