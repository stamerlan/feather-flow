import argparse
import os
import pathlib
import sys
import textwrap
from .planer import Planer

def main() -> None:
    parser = argparse.ArgumentParser(
        prog="pyplaner",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent("""\
            Generate digital planner files from Jinja2/HTML templates.

            Output files are named after the template stem (e.g. template.html
            produces template.pdf and/or template.html) and are written to the
            current working directory, or to the directory given by -C.
            If the output directory does not exist, it will be created.

            Use --html and/or --pdf to select which formats to produce.
            When neither is given, only PDF is generated by default."""),
        epilog=textwrap.dedent("""\
            examples:
              pyplaner planner.html
                  Generate planner.pdf in the current directory.

              pyplaner planner.html --html --no-pdf
                  Generate only the rendered HTML, skip PDF.

              pyplaner planner.html --html --pdf
                  Generate both planner.html and planner.pdf.

              pyplaner -C output/ planner.html
                  Write output files into the output/ directory.

              pyplaner -q planner.html
                  Generate PDF without printing progress."""),
    )
    parser.add_argument("files", nargs="+", type=pathlib.Path,
        metavar="FILE", help="planner template file(s)")
    parser.add_argument("--html", action=argparse.BooleanOptionalAction,
        default=None, help="generate HTML output")
    parser.add_argument("--pdf", action=argparse.BooleanOptionalAction,
        default=None, help="generate PDF output")
    parser.add_argument("-C", "--directory", type=pathlib.Path, default=None,
        metavar="DIR", help="change to DIR before writing output files")
    parser.add_argument("--pdf-optimize", action=argparse.BooleanOptionalAction,
        default=True,
        help="post-process PDF to deduplicate images/streams and strip "
             "obsolete metadata (default: enabled)")
    parser.add_argument("-q", "--quiet", action="store_true",
        help="suppress informational output")
    args = parser.parse_args()

    # Resolve file paths relative to the current working directory
    args.files = [p.resolve() for p in args.files]

    # Change to the output directory if given
    if args.directory:
        args.directory.mkdir(parents=True, exist_ok=True)
        os.chdir(args.directory)

    # Determine which formats to generate.
    # If neither --html nor --pdf is given, PDF is generated by default
    generate_html = bool(args.html)
    generate_pdf = args.pdf or (args.html is None and args.pdf is None)

    # Check for conflicts between template and output files.
    cwd = pathlib.Path.cwd().resolve()
    for path in args.files:
        if generate_html and path == (cwd / f"{path.stem}.html"):
            print(f"Error: output file {path.stem}.html would overwrite "
                  f"template {path}", file=sys.stderr)
            sys.exit(1)
        if generate_pdf and path == (cwd / f"{path.stem}.pdf"):
            print(f"Error: output file {path.stem}.pdf would overwrite "
                  f"template {path}", file=sys.stderr)
            sys.exit(1)

    # Generate the output files.
    for path in args.files:
        planner = Planer(path)

        if generate_html:
            html_path = f"{path.stem}.html"
            if not args.quiet:
                print(f"Generating {html_path}...")
            with open(html_path, "w", encoding="utf-8") as f:
                f.write(planner.html())

        if generate_pdf:
            pdf_path = f"{path.stem}.pdf"
            if not args.quiet:
                print(f"Generating {pdf_path}...")
                timing_cb = (lambda phase, seconds:
                    print(f"  {phase:15s}: {seconds:.3f}s")
                )
            else:
                timing_cb = None # type: ignore[assignment]
            with open(pdf_path, "wb") as f:
                f.write(planner.pdf(
                    pdf_optimize=args.pdf_optimize,
                    timing_cb=timing_cb,
                ))

if __name__ == "__main__":
    main()
