import argparse
import pathlib
import sys
import textwrap
from .calendar import Calendar
from .dayinfo import DayInfoProvider
from .planer import Planer
from .weekday import WeekDay

def main() -> None:
    parser = argparse.ArgumentParser(
        prog="pyplaner",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent("""\
            Generate digital planner files from Jinja2/HTML templates.

            Output files are named after the template stem (e.g. template.html
            produces template.pdf and/or template.html) and are written to the
            current working directory.

            Use --html and/or --pdf to select which formats to produce.
            When neither is given, only PDF is generated by default."""),
        epilog=textwrap.dedent("""\
            examples:
              pyplaner planner.html
                  Generate planner.pdf in the current directory.

              pyplaner planner.html --html --no-pdf
                  Generate only the rendered HTML, skip PDF.

              pyplaner planner.html --html --pdf
                  Generate both planner.html and planner.pdf.

              pyplaner planner.html --country pl
                  Generate PDF with Polish public holidays.

              pyplaner planner.html --provider my_holidays --country us
                  Use a custom provider to fetch holidays / off-days.

              pyplaner planner.html --country us
                  Holidays for the US; week automatically starts on Sunday."""),
    )
    parser.add_argument("files", nargs="+", type=pathlib.Path,
        metavar="FILE", help="planner template file(s)")
    parser.add_argument("--html", action=argparse.BooleanOptionalAction,
        default=None, help="generate HTML output")
    parser.add_argument("--pdf", action=argparse.BooleanOptionalAction,
        default=None, help="generate PDF output")
    parser.add_argument("--pdf-optimize", action=argparse.BooleanOptionalAction,
        default=True,
        help="post-process PDF to deduplicate images/streams and strip "
             "obsolete metadata (default: enabled)")
    parser.add_argument("-c", "--country", default=None, metavar="CC",
        help=(
            "ISO 3166-1 alpha-2 country code for holidays / off-days "
            "(e.g., PL, US, DE, FR, etc.). "
            "Also sets the first day of the week for that country "
            "unless --first-weekday is given explicitly. "
            "Uses the built-in providers by default; combine with "
            "--provider to use a custom provider instead."
        ))
    parser.add_argument("-w", "--first-weekday", default=None, metavar="DAY",
        help=(
            "first day of the week: name (monday, tuesday, ..., sunday) "
            "or number (0=monday .. 6=sunday). "
            "Overrides the country default when --country is also set. "
            "Default: monday"
        ))
    parser.add_argument("--provider", action="append",
        metavar="MODULE",
        help="load custom day-info provider classes from the given Python "
             "module (may be specified multiple times); "
             "default: pyplaner.providers")
    parser.add_argument("-q", "--quiet", action="store_true",
        help="suppress informational output")
    args = parser.parse_args()

    # Determine which formats to generate.
    # If neither --html nor --pdf is given, PDF is generated by default
    generate_html = bool(args.html)
    generate_pdf = args.pdf or (args.html is None and args.pdf is None)

    dayinfo: DayInfoProvider | None = None
    if args.country:
        if args.provider is None:
            args.provider = ["pyplaner.providers"]

        for mod_name in args.provider:
            try:
                providers_cls = DayInfoProvider.load(mod_name)
            except (ModuleNotFoundError, ImportError, TypeError) as e:
                print(f"Warning: {e}", file=sys.stderr)
                continue
            for cls in providers_cls:
                try:
                    dayinfo = cls(args.country)
                    break
                except ValueError:
                    continue
            if dayinfo is not None:
                break

        if dayinfo is None:
            raise ValueError(
                f"No day-info provider found for country {args.country!r}."
            )

    # Resolve first weekday: explicit flag > country default > Monday.
    if args.first_weekday is not None:
        firstweekday = WeekDay.parse_weekday(args.first_weekday)
    elif args.country:
        firstweekday = WeekDay.first_weekday_for_country(args.country)
    else:
        firstweekday = 0

    # Generate the output files.
    calendar = Calendar(firstweekday=firstweekday, provider=dayinfo)

    for path in args.files:
        planner = Planer(path, calendar=calendar)

        if generate_html:
            html_path = f"{path.stem}.html"
            if not args.quiet:
                print(f"Generating {html_path}...")
            with open(html_path, "w", encoding="utf-8") as f:
                f.write(planner.html())

        if generate_pdf:
            pdf_path = f"{path.stem}.pdf"
            if not args.quiet:
                print(f"Generating {pdf_path}...")
                timing_cb = (lambda phase, seconds:
                    print(f"  {phase:15s}: {seconds:.3f}s")
                )
            else:
                timing_cb = None # type: ignore[assignment]
            with open(pdf_path, "wb") as f:
                f.write(planner.pdf(
                    pdf_optimize=args.pdf_optimize,
                    timing_cb=timing_cb,
                ))

if __name__ == "__main__":
    main()
